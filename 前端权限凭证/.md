
### Cookie
* cookie 由服务端生成。cookie 就是一个存放在客户端的一个小文件，也可以存放在本地，假设浏览器关闭后 cookie 依旧存在
https://juejin.cn/post/6844904095711494151#heading-1

#### cookie 的设置过程
1. 客户端向服务器发送一个 HTTP 请求。
2. 服务器接收到请求后在响应头添加一个 `set-cookie` 的字段
3. 客户端接收到服务器的响应后有 `Set-Cookie` 将 cookie 保存下来，保存到本地的文件夹内
4. 之后浏览器每一次请求都会携带 cookie 发送给服务器（耗性能）
5.  cookie 不能跨域，域名有属性值 domain 绑定，但是 webStorage 可以实现跨域


* Cookie 的某一些属性
  - Name：就是 cookie 的属性名
  - Value：cookie 的属性值，需要做编码处理
  - Expire：设置 cookie 的过期时间，Set-Cookie:Expires=Wed, 21 Oct 2015 07:28:00 GMT; **需要注意的是如果 cookie 的 Expire 没有设置，那么表示这个 cookie 是会话 cookie 浏览器关闭后就消失了。持久性的 cookie 是存放在硬盘中的，直到时间过期或者手动清除**
  - max-age：表示 cookie 失效之前的秒数，`Set-Cookie:Max-Age=604800;` 这个属性的值可以是正数：表示持久性的 cookie。负数：表示会话的 cookie 浏览器关闭就消失。0：表示立即删除这个cookie。**当 Max-Age 和 Expire 都存在是，Max-Age 的优先级更高**
  - size：cookie 的大小，超过 4kB 后会被忽略。
  - Domain: 记录域名信息， 但是不能跨站点设置域名，不会起作用
  - path：发送的 http 请求路径可以携带的 cookie。
  - SameSite：限制第三方对 cookie 的携带请求，这属性可以防止 CSRF 攻击。三个重要的属性 strict：仅仅允许同一个域名的站点携带 cookie。Lax：允许部分第三方 get 请求携带 cookie 值，`但是只能在 get 方法提交表单况或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能`。None：表示允许任何站点携带 cookie。一开始默认值是 None，后来默认值是 Lax。
  - HttpOnly: 限定 cookie 只能通过 HTTP 传输，JavaScript 不能读取，防止 XSS 攻击
  - Secure：限定了只有 HTTPS 才可以传输 cookie，HTTP 不能携带 cookie
* 优点：
  - 记录用户的操作状态，密码等
  - 弥补了 HTTP 的无状态

* 缺点：
  - 容量小只有 4kb
  - 不安全，可以随意修改 cookie 内容
  - 耗费性能，每一次请求都会携带完整的 cookie

> domain：域名信息， path：cookie的路径，sameSite：限制第三方对 cookie 的读取，有效防止 CSRF 攻击。HttpOnly：限制 JavaScript 对 cookie 的读取，有效防止 XSS 的攻击。secure：限制了只有 HTTP 才可以读取 cookie。优点：有状态能记录用户的操作行为账号密码等。弥补 HTTP 的无状态。缺点：体积小只有 4kb，而且不安全 cookie 可以被修改。消耗性能，每一次请求都会携带 cookie。


### session
> session 是另一种记录服务器和客户端会话的机制，也具备状态，session 也是一个文件
* session 是基于 cookie 实现的，但是 session 存在服务器端，sessionID 存在 cookie 中，但是 sessionID 也可以存放在 url 后面。
* session 存于服务器端比 cookie 要安全。
* session 的有限期默认在会话结束或者 Session 超时后会被关闭(默认时间30分钟)，cookie 可以设置
* session 可以存任意的数据类型，cookie 只能存字符串。
* session 没有大小限制，所以，可以储存任意数量的数据。
* (缺点) 会占用服务器的内存，如果认证的用户过多。
* (缺点) 基于 cookie 实现的 session 也可能会遭受 CSRF 攻击
> 要实现 session 的跨域可以将 session 的数据进行共享到其他服务器也能进行访问，或保证 cookie 的 sessionID 值相同。

__特别注意：浏览器关闭后不会导致 服务器 session 的消失，浏览器关闭后会话型的 cookie 存储的 sessionID 也会消失，那么服务器上的session就不会再使用。直到 session 的时间到期才会被销毁，浏览器的关闭不会直接导致session的销毁__


sessionID：随机数+时间

### session 认证的过程
* 用户向服务器发送用户名和密码
* 服务器认证通过后，会生成当前的会话 session 和 sessionID，session 保存用户的角色、登陆时间等信息
* 服务器返回这个 sessionID 给浏览器，浏览器将 sessionID 写入到 cookie 中
* 下次用户的每一次请求都会携带 cookie，将 sessionID 返回给服务器
* 服务器接收到 sessionID 后通过对比，就知道用户的身份了


* 缺点：session 扩展性不好，服务器集群的要求共享 session。(A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录)。
* 为了实现 session 数据共享的方式，服务器直接不再保存 session，所有的数据直接保存在浏览器中，每一次的请求都发回给服务器，JWT(Json Web Token) 就是这样的实现方式。


### token 令牌
* token 可以分为三种：自定义的 token
* jwt token 按照 RFC 7519 规范的 token；
* Oauth2.0：定义在 RFC 6750 中的一种授权规范，其实并不是一种 token，只是其中也有用到 token


### token 特点
* token 无状态，扩展性好
* 安全性高
* 支持移动端设备



[token认证过程](./img/token认证过程.jpg)
### 自定义 token 
#### Access Token  资源凭证
* 用户登陆后发送账号和密码给服务器认证，服务器认证通过后，将用户名和密码(登陆时间戳，sign签名)作为加密后数字签名，通过加密后得到 token 字符串。
* 服务器将 token 发送给浏览器，浏览器接收到 token 后会存储在 cookie 或 localStorage，sessionStorage 中。
* 客服端每一次向服务端请求资源时都携带上 token，token 可以存放在请求头 Header 中。
* 服务端接收到 token 后，会认证，认证成功就返回需要的数据。
* token 不受同源策略的影响，没有跨域问题。
> 需要注意的时，token 认证的这种方式是服务器的无状态认证方式



#### Refresh Token
* Refresh Token 专门用于刷新过期后的 Access Token 的。减少用户的重复登陆
* Refresh Token 如果过期了那么用户就只能重新登陆了。
* Refresh Token 和 Access Token 不同，Refresh Token 时存放在服务器端的，只有申请新的 Access Token 时才会去认证。



### token 和 Session 的一个区别
* Session 是一个记录浏览器和服务器会话状态的机制。token 是一个令牌，是资源请求的凭证。
* 两者完全不一样，而且相互独立。



### JWT （JSON Web Token） token 令牌的一种
* JWT 是目前最流行的跨域认证方案(token 也可以跨域认证，)
* JWT 使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。
* 服务器认证用户通过后会生成一个 json 格式的用户信息，再通过算法做数字签名，保证认证信息的可靠性。
``` js
// 比如
{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2021年7月1日0点0分"
}
```
> 将上面的用户信息进行算法签名。
* 此后服务器不会再保存 session 数据，服务器变成了无状态。

### JWT 认证流程
* 用户输入用户名和密码后发送给服务器，服务器认证后通过加密会形成一个 JWT 字符串发送给浏览器
* 浏览器将 jwt 保存在本地，一般保存在 localStorage 中 也可以是 cookie。
* 当用户访问受保护需要认证的接口或资源时，需要在请求头中 `Authorization` 字段中使用 `Bearer` 模式配置 JWT。
``` js
Authorization: Bearer<token>
```
* 服务器认证传递过来的头部 jwt 如果是合法的，就会允许访问，因为 jwt 自包含了用户的信息，所以减少了查询数据库的操作。


### JWT 的使用方式
* 放在 cookie 中，但是不能实现跨域问题。
* 放在 localStorage 中，添加在请求头的 Authorization 的 Bearer 模式内
* 放在请求体 body 或 请求的url的 queryString 中，跨域的时候 JWT 之间放在 POST 的请求体中。


### JWT 三段组成
* JWT 有三部分组成，中间以 `.` 隔开。
* 由 `Header.payload.signature` 三部分组成。
* header 头部，payload 负载，signature 签名


#### Header 头部
* header 头部是一个 json 对象，由算法，token 类型组成
``` js
{
  "alg":"HS256",
  "typ":"JWT"
}
```
> alg 是签名的算法，"typ" 是token的类型，JWT 统一写成 `jwt`。上面的 json 对象最后会使用`Base64URL`算法转化成字符串。


#### payload 负载
* payLoad 负载是我们真正要传递数据的部分，也是一个json对象。
* payload 负载，官方提供了 7 个字段，但是因为可以添加自定义的字段。
* 七个字段分别是：`iss(issuer): 签发者，sub(subject)主题，exp(expiration time)过期时间，aud(audience) 受众，nbf (Not Before)：生效时间，iat (Issued At)：签发时间，jti (JWT ID)：编号`。主题、过期时间、生效时间、签发者、签发时间
* 还可以添加自定义的字段
``` js
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```
> 这个对象也需要使用 Base64URL 算法转化成字符串。

#### signature 签名
* signature 部分主要是通过一个密钥 secret 对前面的两部分 header、payload 做签名。
* 密钥 secret 只能有服务端保存

#### 签名产生
* 最后使用 header 头部中的签名算法按照一定的公式计算出签名，签名的最后由三部分组成，由`header，payload, signature`，三部分由 `.` 隔开
``` js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

#### Base64URL 算法
* JWT 有时需要添加到 url 的 queryString 中，那么需要将一些特殊字符变化一下，`=` 会被忽略，`+` 会被变成 `-` 号，`/` 替换成 `_`。


### JWT 特点
* JWT 默认是不加密的，可以使用 secret 加密一次。
* JWT 具备无状态的特点，自包含了用户的信息，服务端只需要解密进行校验，不需要查询数据库，减少了数据库的查询次数。
* JWT 的无状态不保存 session 是优点也是缺点，由于 session 的无状态，那么一旦 jwt 生效，就不能取消，直到失效，所以 jwt 的生命时间应该很短。下次的请求再生成一个新的 jwt。
* 为了减少 jwt 被盗用，使用 https 的加密协议，不适用 http 协议。



### 自定义 token 和 JWT 的区别
[自定义 token 和 JWT](https://www.codenong.com/j5e8c1ba0f265da4804698aa0/)
* 都是访问资源的令牌，都可以服务器的无状态化，都只有认证成功后才可以访问资源。两者存储的位置相同。
* 区别：自定义 token 的认证需要服务器的数据库查询操作，但是 jwt 只需要服务端去解密认证，不需要查询数据库的状态，因为 jwt 包含用户的信息。