字节。
英文字母表顺序
``` js
function generateBig_1(){
    var str = [];
    for(var i=65;i<91;i++) {
        str.push(String.fromCharCode(i));
    }
    return str;
}
generateBig_1()
// ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
```


``` js
function sortFn(sum) {
    let arr = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
    let l = 0
    let r = -1
    while (arr.length <= sum) {
        if (r < 26) {
            arr.push(arr[l] + arr[r + 1])
            r++
            if (arr.length == sum) {
                break
            }
        }
        if (r === 25) {
            l++
            r = -1
        }

    }
    console.log(arr)
}
console.log(sortFn(1000))
```

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...


``` js
var convertToTitle = function (columnNumber) {
    let arr = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

    // 小于等于26，直接返回
    if (columnNumber <= 26) return arr[columnNumber - 1];
    let res = '';
    while (columnNumber > 0) {
        // n先减1
        columnNumber--;
        // 从后往前拼接
        res = arr[columnNumber % 26] + res;
        columnNumber= Math.floor(columnNumber / 26);
    }
    return res;
};
```


### 螺旋矩阵
``` js
var spiralOrder = function (matrix) {
    if (matrix.length == 0) return []
    // top， bottom 控制层级移动，left，right 控制左右移动
    let top = 0,
        bottom = matrix.length - 1,
        left = 0,
        right = matrix[0].length - 1;
    let len = matrix.length * matrix[0].length
    let res = []
    while (res.length !== len) {
        // i 的左右取值一定是 top、bottom、left、right 中的一个。
        // 左到右
        for (let i = left; i <= right; i++) {
            res.push(matrix[top][i])
        }
        top++

        // 这个条件放在这里就可以了，top 和 bottom 同时处于一层说明只剩下最后一层了，只需要从左到右遍历即可
        if (res.length === len) break

        // 上到下
        for (let i = top; i <= bottom; i++) {
            res.push(matrix[i][right])
        }
        right--

        // 右到左
        for (let i = right; i >= left; i--) {
            res.push(matrix[bottom][i])
        }
        bottom--

        // 下到上
        for (let i = bottom; i >= top; i--) {
            res.push(matrix[i][left])
        }
        left++
    }
    return res
};

let s = spiralOrder([
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 16]
])
// 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10
```

## 回文字符
> 正着读和反着读一样，所以回文串是对称的

### 判断是否是回文串
* 解法：对撞指针遍历


### 求最长回文串
[求最长回文串](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-by-xing-gua-zdqs/)
* 解法：中间扩展法，利用回文串的对称性，因为回文串可能是奇数也可能是偶数，所以要分两种情况
``` js
// 中心对称扩散法
var longestPalindrome = function (s) {
    let res = ''
    for (let i = 0; i < s.length; i++) {
        // 奇数的回文数
        helper(i, i)
        // 偶数的回文数，逐步加 1 
        helper(i, i + 1)
    }

    function helper(l, r) {
        while (l >= 0 && r <= s.length && s[l] === s[r]) {
            l--
            r++
        }

        // 只有长度比 res 长的才取值
        if (r - l - 1 > res.length) {
            res = s.slice(l + 1, r)
        }
    }
    return res
};
```

### 剑指 Offer 63. 股票的最大利润
https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/
``` js
// 双指针逐步先前比较
var maxProfit = function (prices) {
    let l = 0
    let r = 0
    let res = 0
    while (l <= prices.length - 1) {
        if (prices[r + 1] > prices[l]) {
            res = Math.max(res, prices[r + 1] - prices[l])
        }
        r++
        r === prices.length ? (l++, r = l) : null
    }
    return res
};
```

### 大数相加
https://leetcode-cn.com/problems/add-strings/
``` js
// 双指针由低位到高位逐步向上相加。长度不相等的补 0。
var addStrings = function(num1, num2) {
    let i = num1.length - 1, j = num2.length - 1, add = 0;
    const ans = [];
    while (i >= 0 || j >= 0 || add != 0) {
        // 隐式转换 '1' - '0' = 1
        const x = i >= 0 ? num1.charAt(i) - '0' : 0;
        const y = j >= 0 ? num2.charAt(j) - '0' : 0;

        const result = x + y + add;
        // 求个数
        ans.push(result % 10);
        // 求进位数
        add = Math.floor(result / 10);

        i -= 1;
        j -= 1;
    }
    return ans.reverse().join('');
};
```



## Scheduler 调度器
// JS实现一个带并发限制的异步调度器Scheduler，
// 保证同时运行的任务最多有两个。
// 完善代码中Scheduler类，
// 使得以下程序能正确输出
``` js
// 完善代码中Scheduler类，使得以下程序能正确输出
class Scheduler {
    constructor() {
        let res = []
    }
    add(promiseCreator) {}
}
const timeout = (time) => new Promise(resolve => {
    setTimeout(resolve, time)
})

const scheduler = new Scheduler()

const addTask = (time, order) => {
    scheduler.add(() => {
        return timeout(time)
    }).then(() => console.log(order))
}

addTask(1000, '1')
addTask(500, '2')
addTask(300, '3')
addTask(400, '4')
// output: 2 3 1 4
// 一开始，1、2两个任务进入队列
// 500ms时，2完成，输出2，任务3进队
// 800ms时，3完成，输出3，任务4进队
// 1000ms时，1完成，输出1
// 1200ms时，4完成，输出4

// 1
class Scheduler {
	constructor(count) {
		this.count = 2
		this.queue = []
		this.run = []
	}

	add(task) {
		this.queue.push(task)
		return this.schedule()
	}

	schedule() {
		if (this.run.length < this.count && this.queue.length) {
		  	const task = this.queue.shift()
		  	const promise = task().then(() => {
		  		this.run.splice(this.run.indexOf(promise), 1)
		  	})
		  	this.run.push(promise)
		  	return promise
		} else {
		  	return Promise.race(this.run).then(() => this.schedule())
		}
	}
}

// 2
class Scheduler {
    concurrency = 2
    running = 0
    queue = []

    add(task) {
        return new Promise(resolve => {
            this.queue.push({
                taskGenerator: task,
                resolve
            })
            this.schedule()
        })
    }

    schedule() {
        while (this.queue.length > 0 && this.running < this.concurrency) {
            const curTask = this.queue.shift()
            this.running += 1
            curTask.taskGenerator().then(result => {
                this.running -= 1
                curTask.resolve(result)
                this.schedule()
            })
        }
    }
}

const timeout = (time) => new Promise(resolve => {
    setTimeout(resolve, time)
})

const scheduler = new Scheduler()

const addTask = (time, order) => {
    scheduler.add(() => {
        return timeout(time)
    }).then(() => console.log(order))
}

addTask(1000, '1')
addTask(500, '2')
addTask(300, '3')
addTask(400, '4')
// output: 2 3 1 4
// 一开始，1、2两个任务进入队列
// 500ms时，2完成，输出2，任务3进队
// 800ms时，3完成，输出3，任务4进队
// 1000ms时，1完成，输出1
// 1200ms时，4完成，输出4
```


## 打印三角形
//     *
//    ***   
//   *****  
//  ******* 
// *********

``` js
function dengyao(num) {
    // i 控制行数
    for (let i = 1; i <= num; i++) {
        // j 控制前面空格数 空格数 = 总行数减去当前行数 +1 
        let space = new Array(num - i + 1).join(" ")
        // k 控制每行星星个数 星星个数=两倍当前行数减一 也就是 (2*i-1)
        let star = new Array(i * 2).join("*")
        console.log(space + star);
    }
}
dengyao(5)
```

## 题目：Excel 序列
/**
 * 设定如下对应关系
     A: 1,
     B: 2,
     C: 3,
     ...
     Z: 26,
     AA: 27,
     AB: 28,
     AC: 29,
     ...
     AZ: 52,
     BA: 53,
     BB: 54,
     ...
     ZZ: 702
     AAA: 703
     AAB: 704
     ...
 * 写一个转换函数，根据上面规则把一个字符串转换为数字
 * str2Int('ABCDEFG') → 334123303
 */
// 相当于 26 进制转 10 进制。

// FXSHRXW
// 23×26^0+24×26^1+18×26^2+8×26^3+19×26^4+24×26^5+6×26^6=2147483647

```js
// 关键在于 columnTitle[i].charCodeAt() - 'A'.charCodeAt() + 1; 得到位数和 26 进制计算。
var titleToNumber = function (columnTitle) {
    let number = 0;
    let multiple = 1;
    for (let i = columnTitle.length - 1; i >= 0; i--) {
        const k = columnTitle[i].charCodeAt() - 'A'.charCodeAt() + 1;
        console.log(k)
        number += k * multiple;
        multiple *= 26;
    }
    return number;
};

titleToNumber('FXSHRXWFXSHRXW')
```

// 解法2
``` js
const titleToNumber = str => {
    const map = {
        A: 1,
        B: 2,
        C: 3,
        D: 4,
        E: 5,
        F: 6,
        G: 7,
        H: 8,
        I: 9,
        J: 10,
        K: 11,
        L: 12,
        M: 13,
        N: 14,
        O: 15,
        P: 16,
        Q: 17,
        R: 18,
        S: 19,
        T: 20,
        U: 21,
        V: 22,
        W: 23,
        X: 24,
        Y: 25,
        Z: 26,
    };
    let res = 0;
    const len = str.length;
    for (let i = 0; i < len; i++) {
        // 根据map取得字母对应的数字
        res += map[str[i]] * 26 ** (len - i - 1);
    }
    return res;
};


```


