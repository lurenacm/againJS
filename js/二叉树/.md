## 树
* js 中可以使用 Object，Array构建树的结构。例如 vue 中的虚拟DOM
* 二叉树的遍历算法，分为深度/广度优先遍历、先中后序遍历

## 深度和广度优先遍历
[深度和广度](./img/深度广度优先遍历.jpg)
* 深度遍历是指：尽可能深的遍历树的节点。例如左边的树结构是从最上层根节点遍历到最下层的
* 广度优先遍历指：从离根节点最近的子节点处访问，逐步访问完所有子节点。第一层b c中，b离根节点最近，因为 b 先被访问所以先访问 d e再访问 f g，广度遍历从 `a-b-c-d-e-f-g` 遍历

### 深度优先遍历算法
* 步骤一：先访问根节点
* 步骤二：对根节点下面的子节点逐步遍历，这里涉及到递归
> 深度优先遍历的过程就是递归的过程。根节点a访问了到访问子节点b，b根节点访问后到子节点d，最后到子节点e。
* 实现如下：
``` js
const tree = {
    val: "a",
    children: [{
            val: "b",
            children: [{
                    val: "d",
                    children: []
                },
                {
                    val: "e",
                    children: []
                }
            ]
        },
        {
            val: "c",
            children: [{
                val: "f",
                children: []
            }, {
                val: "g",
                children: []
            }]
        }
    ]
}

function dfs(root){
    console.log(root.val)
    root.children.forEach(element => {
        dfs(element)
    });
}
dfs(tree)
```


### 广度优先遍历算法
* 步骤一：新建一个队列，将根节点入队
* 步骤二：队头的根节点出队并访问
* 步骤三：最近的子节点挨个全部入队
* 步骤四：重复第二、第三步骤，直到队列清空
> 先访问a，b，后b的子节点入队，访问c，c的子节点入队，再访问d...依次清空，只有根节点出队访问了，子节点才可以入队
``` js
function bfs(root) {
    let q = [root]
    while (q.length > 0) {
        let res = q.shift()
        console.log(res.val)
        res.children.forEach(child => {
            q.push(child)
        });
    }
}
bfs(tree)
```

xiao tong
晓彤(tong)
## 二叉树
> 树具备多种结构，有二叉树和多叉树，上面的例子就是多叉树
* AVL 树、红黑树、B树、堆、Trie、哈夫曼树、并查集。
* 二叉树的每一个节点最多有两个子节点。
* 在 JS 中通常使用 Object 来模拟二叉树。
``` js
let obj = {
    val: 1,
    left: {
        val: 2,
        left: {
            val: 4,
            left: null,
            right: null
        },
        right: {
            val: 5,
            left: null,
            right: null
        }
    },
    right: {
        val: 3,
        left: {
            val: 6,
            left: null,
            right: null
        },
        right: {
            val: 7,
            left: null,
            right: null
        }
    }
}
```
* 二叉树具备三种遍历方式，先序遍历，中序遍历，后序遍历


### 满二叉树和完全二叉树
* 满二叉树：满二叉树是指假设二叉树的深度为 k，那么二叉树的节点数是 2^k-1 的节点的二叉树就是满二叉树
* 完全二叉树是指，深度为h的二叉树，除了 h 层以外，其余的 1~h-1 的节点数都达到最大个数，且 h 层的所有节点都在最左边的左子树。

对于满二叉树，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。
完全二叉树: 除了最后一层的没有子节点且在最左边的左子树之外，其他层节点都有两个字节点。


### 二叉树的先序遍历 (根左右)
[先序遍历](./img/先序遍历.jpg)
* 先序遍历的访问顺序：根节点(1)，根的左子树(2-3-4-5)，根的右子树(6-7)。左子树结束后才开始右子树遍历。
* 访问左子树需要访问到尽头(递归过程)，再访问上一个根节点的右子树
* 步骤一：访问 `根节点`
* 步骤二：访问根节点的 `左子树的根节点`，递归下去直到为 null。
* 步骤三：访问根节点的 `右子树根节点`，重复步骤二，同样递归下去，直到为 null

> 要点在于需要全部左子树的根节点，再遍历右子树的根节点
``` js
function preorder(root){
    console.log(root.val)
    preorder(root.left)
    preorder(root.right)
}
preorder(obj)
```
* 为了剔除不必要的遍历，有些左子树右子树没有子节点就不需要遍历 `if(!root) return`
``` js
function preorder(root){
    if(!root) return
    console.log(root.val)
    preorder(root.left)
    preorder(root.right)
}
preorder(obj)
```

#### 非递归先序遍历
* 递归的创建会形成一个函数调用堆栈，只要能模拟这个栈（后进先出）就可以实现非递归的先序遍历。
``` js
function preorder(root) {
    // 模拟一个栈
    const stack = [root]    
    while (stack.length !== 0) {
        // 访问栈的根节点
        let n = stack.pop(root)
        console.log(n.val)
        // 右子树先入栈，左子树再入栈，才能保证先访问左子树再到右子树
        if(n.right){stack.push(n.right)}
        if(n.left){stack.push(n.left)}
    }
}
```
> 先序遍历没有使用到指针的概念，因为遇到根节点后就直接输出了，没有遍历到尽头才输出。


### 二叉树的中序遍历（左根右）
* 步骤一：先访问根节点的 `左子树`，直到左子树末尾为 null
* 步骤二：后访问末尾的子树的 `根节点`
* 步骤三：再访问根节点的 `右子树`，重复步骤一，直到右子树末尾为 null
``` js
function inOrder(root){
    if(!root) return
    inOrder(root.left)
    console.log(root.val)
    inOrder(root.right)
}

inOrder(obj)
```
> 递归都涉及到 js 栈结构，后进先执行


#### 非递归中序遍历
* 要点：按照递归的思想创建一个栈，逐步入栈，最后逐步出栈，记住是所有的左子树都入栈
* 需要一个指针 p 遍历到末尾节点。
``` js
function inOrder(root) {
    if(!root) return
    const stack = []
    let p = root
    while (stack.length || p) {
        while (p) {
            // 将所有的左子树全部逐步放入队列，
            stack.push(p)
            p = p.left
        }
        // 取出最后一个左子树的值
        let n = stack.pop()
        console.log(n.val)
        // 访问右子树，再通过 while 循环访问左节点
        p = n.right
    }
}
```


### 二叉树的后序遍历（左右根）
* 步骤一：先访问根节点的 `左子树`，直到末尾为 null
* 步骤二：后访问根节点的 `右子树`，重复步骤一，直到末尾为 null
* 步骤三：再访问 `根节点`。
``` js
function postOrder(root) {
    if(!root) return
    nextOrder(root.left)
    nextOrder(root.right)
    console.log(root.val)
}
postOrder(obj)
```


#### 非递归版的后序遍历
> 非递归版的后序遍历比较难以实现，可以将 `左右根->根右左`，有点类似于先序遍历
* 采用多一个栈先存放根节点的值，最后 `倒序循环` 输出才是 `左右根` 后序遍历的结果。
``` js
function postOrder(root) {
    const stack = [root]
    const res = [] // 保存根节点的值
    while (stack.length) {
        let n = stack.pop()
        res.push(n)
        n.left !== null ? stack.push(n.left) : null
        n.right !== null ? stack.push(n.right) : null
    }

    // 倒序输出结果
    while (res.length) {
        let r = res.pop()
        console.log(r.val)
    }
}
postOrder(obj)
```

### 二叉树的最大深度
> 最大深度就是二叉树的层数
* 使用深度优先遍历。需要记录层级

### 二叉树的最小深度
* 使用广度优先遍历，队列的方式，需要记录层级


### 二叉树算法技巧
### 判断末尾节点的方法
``` js
// 末尾节点的判断方法
if(!root.left && !root.right){

}
```


### 记录遍历的层级
``` js
let [q, l] = [[root, 1]]

if(root.left){q.push([root.left, l+1])}
if(root.right){q.push([root.right, l+1])}
```

### 参考
[二叉树前中后序遍历](https://juejin.cn/post/6844904063650234375#heading-0)

### 二叉树的层序遍历
[3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
[
  [3],
  [9,20],
  [15,7]
]

``` js
var levelOrder = function (root) {
    if(!root) return []
    let q = [[root, 0]]
    let res = []
    while (q.length) {
        let [n, l] = q.shift()
        // 自上而下遍历记录的 l，通过导入的下标可以推入一个新数组中
        if(!res[l]){
            res.push([n.val])
        }else {
            res[l].push(n.val)
        }
        if(n.left) q.push([n.left, l+1])
        if(n.right) q.push([n.right, l+1])
    }
    return res
};
```