# JS 是怎样分析代码的，运行的机制是什么？
> **回答这个问题前先看两个示例**
``` js
// 基本类型
    let name = 'LinYY'
    let name2 = name
    console.log(name2)  // LinYY
    name2 = '林一一'
    console.log(name2)  // 林一一
    console.log(name)  // LinYY
// 引用类型
    let obj = {name: 'LinYY'}
    let obj2 = obj
    console.log(obj2.name) // LinYY
    obj2.name = '林一一'
    console.log(obj.name)   // 林一一
```
## 问上面的结果为什么是这样？这涉及到 JS 的运行机制
1. 当浏览器（内核/引擎）渲染和解析 JS 代码时，会提供一个运行环境，这个环境称为全局作用域（global scope）
2. JS 代码自上而下运行。
> 基本数据类型的值会存储在当前作用域下，比如 var age = 18，(1)浏览器会将开辟一个存储空间18，(2)然后在作用域内声明一个变量 age。(3)最后将 18 赋值给变量 age，这个操作过程叫做定义。

> 引用数据类型的值和基本类型不同，引用类型的值不能直接的存储在当前作用域下的，因为存储的内容可能过于复杂。需要新开一个大点的空间（在当前作用域之外），再把内容存在空间中。比如上面的 let obj = {name: 'LinYY'}，（1）先有一个内存空间存储对象的键和值，这空间有一个16进制的地址（2）声明变量 obj（3）obj 再和`16进制空间地址`做关联，也就是将`16进制空间地址`赋值给变量。

## 解答：
> 基本类型也叫做值类型，是按照`值`来操作：**`按值操作`的意思是将值复制一份，放在了新的存储空间，和原来的值就没有关系了。**，所以上面的 name2 最后值改边成了 '林一一'，也不会影响 name
> 引用类型不是按值操作，是按空间引用地址来操作：同样**将空间引用地址复制一份给新的对象，但是存储的空间没有被复制**，也就是说**新的对象和旧的对象指向的存储空间都是同一个，所以新对象操作行为会对旧对象有影响**，obj2 影响 obj。


> `栈内存` : 存储全局作用域，是JS 代码执行的环境，所有基本类型值都会在栈内存中开辟一个位置进行存储。
> `堆内存`: 存储引用类型中的值，对象是键值对，函数是字符串。

``` !
    参考：高程4 83页。
```