# JS 是怎样分析代码的，运行的机制是什么？
> **回答这个问题前先看两个示例**
``` js
// 基本类型
    let name = 'LinYY'
    let name2 = name
    console.log(name2)  // LinYY
    name2 = '林一一'
    console.log(name2)  // 林一一
    console.log(name)  // LinYY
// 引用类型
    let obj = {name: 'LinYY'}
    let obj2 = obj
    console.log(obj2.name) // LinYY
    obj2.name = '林一一'
    console.log(obj.name)   // 林一一
```
## 问上面的结果为什么是这样？这涉及到 JS 的运行机制
1. 当浏览器（内核/引擎）渲染和解析 JS 代码时，会提供一个运行环境，这个环境称为全局作用域（global scope）
2. JS 代码自上而下运行。
>* 基本数据类型的值会存储在当前作用域下，但遇到基本类型时，直接在当前作用域（`栈内存`）内开辟空间存储值，比如 var age = 18，(1)浏览器会在当前作用域内开辟一个存储空间18，(2)然后在作用域内声明一个变量 age。(3)最后将 18 赋值给变量 age，这个操作过程叫做定义。
>* 当遇到引用类型时，因为存储的内容可能过于复杂，`需要在栈内存之外的堆内存中开辟空间存储内容再把这个堆内存的空间地址给要赋值的变量`。比如上面的 let obj = {name: 'LinYY'}，（1）先有一个内存空间存储对象的键和值，这空间有一个16进制的地址（2）声明变量 obj（3）obj 再和`16进制空间地址`做关联，也就是将`16进制空间地址`赋值给变量。

## 解答：
> 基本类型也叫做值类型，是按照`值`来操作：**`按值操作`的意思是将值复制一份，放在了新的存储空间，和原来的值就没有关系了。**，所以上面的 name2 最后值改边成了 '林一一'，也不会影响 name
> 引用类型不是按值操作，是按空间引用地址来操作：同样**将空间引用地址复制一份给新的对象，但是存储的空间没有被复制**，也就是说**新的对象和旧的对象指向的存储空间都是同一个，所以新对象操作行为会对旧对象有影响**，obj2 影响 obj。


> `栈内存` : 存储全局作用域，是JS 代码执行的环境，所有基本类型值都会在栈内存中开辟一个位置进行存储。
> `堆内存`: 存储引用类型中的值，对象是键值对，函数是字符串。

``` !
    参考：高程4 83页。
```

[类型](https://github.com/lurenacm/againJS/blob/main/js/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/.md)