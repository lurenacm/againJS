###  JS 中的内存分配
* 64位系统分配 1.6G
* 32位系统分配 0.7G

JS 中的内存存放会放在栈内存和堆内存中
* 栈内存的垃圾回收比较容易，当指针下移，处于栈顶的元素就会被自动回收，基本类型的定义就存在栈内存中
* 堆内存的垃圾回收比较复杂，对象类型存放再堆内存中，V8 会限制堆内存的上限


###  V8 限制堆内存上限的原因。
* JS 是单线程的限制。
* JS 垃圾回收的限制。
> JS 的单线程限制，如果进入到垃圾回收状态，那么其他的运行逻辑就要暂停。垃圾回收还会很耗时间，V8 做一次小的垃圾回收会50ms。1.4G 内存完全一次垃圾收集需要 1s 以上。这样的话会导致 JS 代码长时间不执行，造成页面卡顿。所以 V8 限制的堆内存的上限。


###  V8 堆内存的处理方式
* V8 将堆内存分成两部分处理，一个是新生代内存和一个是老生代内存。新生代内存就是存放临时内存的，存活时间短，老生代用于存放常驻内存，存活时间长。
* V8 堆内存就是新生代内存和老生代内存之和大致是 0.7G-1.4G 


###  新生代内存回收 (广度优先的扫描策略)
* 新生代内存在不同系统中分配的大小也是不一样的，64位系统32M，32位系统16M，存活的时间短不需要分配大的内存空间。
* 在新生代内存中还分为两个区 `From` 区、`To` 区，两区各占一半内存。`From` 区是正在使用的区，`To` 区表示目前的闲置区。
* V8 会先将 `From` 区的对象检查一遍，如果还是使用的对象就复制一份放入到我们的 `To` 区，否则直接回收即可。之后 `From` 区和 `To` 区的角色调换。循环反复，这个新生代内存回收的过程使用 `Scavenge /sgavendge/` 算法。`scavenge` 的算法缺陷在于，内存只能使用新生代内存的一半，浪费了另一半内存。
* 经历过 5 次循环还在的对象会被移入到 `老生代内存区`，这种现象叫做晋升，或在 `To` 区的存活对象占用内存中 25% 也会被移入到老生代区。
  
  
###  老生代内存回收
* 老生代内存的垃圾回收不再使用 `scavenge` 算法。
* 老生代内存回收分为两种，采用`标记-清除`，`标记-整理`策略

####  标记-清除策略(Mark-Sweep)
* 标记阶段：先遍历老生代内存中的所有对象，全部做上标记。
* 清除阶段：对于还在代码 `存活的变量` 会取消标记，剩下没有取消标记的代码就会被清除
> 这样会还会造成文档碎片的问题，V8 使用标记-整理来处理这个问题
  
  
####  标记-整理(Mark-Compact)
* 标记整理就是来整理文档碎片的，将还存活的对象左移。整理文档碎片由于要移动对象，这部分最消耗时间。V8 为了解决标记整理阶段的时间消耗，采取了一个方案 `增量标记` 的方式。
  
  
###  增量标记
* 所谓的增量标记是指，原本一次性全部标记的变量，现在分成小部分去执行。没标记一小部分就让 JS 的代码执行。直到所有的变量都标记完成，才开始整理文档碎片。这样JS 的执行就不会缓慢变得卡顿。
  
  
  