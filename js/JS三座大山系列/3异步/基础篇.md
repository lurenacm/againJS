## 一、定时器
> 定时器：设定一个定时器，到了设定时间，浏览器会把对应的方法执行。每一个定时器执行后都会有一个编号返回，每个定时器编号不一样。
### 1. 设定定时器
* setTimeout([function], [interval])
> function 都是在到达设定时间后才执行。且执行一次
``` js
let count = 1
let timer = setTimeout(function(){
    count++
    console.log(count)  // 2
}, 1000)
console.log(timer)  // 1
```
* setInterval([function], [interval])
> 在设定时间内执行，不主动停止的情况下一直执行。
``` js
let count = 1
let timer = setInterval(function(){
    count++
    console.log(count)  // 2
}, 1000)
console.log(timer)  // 1
/*
*   2
*   3
*   4
*   ...
*/
```
### 2. 清除定时器
> `clearTimeout/clearInterval` 两者都可以清除上面的两种定时器。
* 如何清除定时器？
> 只需要定时器的返回值编号清除即可。
```js
let count = 1
let timer = setInterval(function(){
    count++
    console.log(count)
    // count == 3 ? clearTimeout(timer) : null
    count == 3 ? clearInterval(timer) : null
}, 1000)
```

## 二、异步编程的原理
__先来看一个小例子__
``` js
let a = 0
setTimeout(() =>{
    console.log('a', ++a)
}, 0)
console.log(a)
/* 输出
*   0
*   1
*/
```
> 上面的例子中，`setTimeout` 是异步的，浏览器会将异步的代码加入到任务队列中，等到同步的代码执行完成后才执行异步的代码
### 1. 同步
> JS 是单线程的，代码至上而下执行时遇到同步的代码需要先执行完才可以进行下一步任务。比如循环等

### 2. 异步
> 所有需要等待的任务都是异步的。遇到异步代码时，不需要等待而是直接异步任务放入任务队列，等到后面的任务完成后，才会返回来执行没有完成异步的代码。比如事件绑定，所有定时器，ajax 的异步处理，部分回调函数，浏览器的渲染过程等等。
``` js
let a = 0
setTimeout(() =>{
    console.log('a', ++a)
}, 0)
console.log(a)
while(true){
}
```
> 上面的代码死循环了，即使定时器的时间到了也不会执行。因为同步的代码没有执行完一步就不会执行。

## 三、promise
### 1.基本概念
> `Promise` 只是一个管理异步编程的类，本身是同步。`Promise` 有三个状态 `pending/fulfilled/rejected`，三个状态只有两个状态出现要么成功要么失败。`new Promise()`时必须要传入回调函数，否则报错。其中回调函数中有两个参数`resolve, reject`，这两个参数可不写。
* `pending` ：初始化状态，开始执行异步的任务
* `fulfilled`：成功状态
* `rejected`：失败状态
__先看一个小栗子。__
``` js
new Promise(()=> {
    setTimeout(()=> {
        console.log(1)
    }, 0)
    console.log(2)
}).then()
console.log(3)
/* 输出
*   2
*   3
*   1
*/
```
> 创建一个新的 `Promise` 的实例也就是 `new` 这个过程中会把 `Promise 中` 的函数先执行(不清楚 `new` 创建实例的过程中发生了什么可以看看这篇 [面试 | 你不得不懂得 JS 原型和原型链](https://juejin.cn/post/6938590449674223624#heading-6))。函数体内有异步操作的仍会加入任务队列，等到同步执行完成后才执行异步任务，比如函数体内的 `setTimeout 函数`。所以输出的结果就是 `2，3，1`。

### 2. promise 是怎么管理异步的
> `promise` 的函数体内接收两个参数 `resolve/ reject`。
> 1. `resolve`：是异步操作执行成功后执行，可以提供返回值，在 `then()` 中接收
> 2. `reject`：异步操作执行失败后执行，可以提供返回值，在 `then()` 中接收
> `resolve` 和 `reject` 中 只能传递一个参数。
__举一个没什么意义的小栗子__
``` js
new Promise((resolve, reject)=> {
    setTimeout(()=> {
        resolve('ok')
        // reject('fail')
    }, 0)
}).then( res => {
    console.log('status:', res)
}, res => {
    console.log('status:', res)
})
```

### 思考
#### 1. promise 的优缺点


#### 2. promise 于 setTimeout() 区别


#### 3. 实现一个 sleep 函数，比如 sleep(1000) 意味着等待 1000 毫秒。



#### 4. Promise 构造函数是同步执行还是异步执行，那么 then 方法呢
``` js
const promise = new Promise((resolve, reject) => {
    console.log(1)
    resolve()
    console.log(2)
})
promise.then(() => {
    console.log(3)
})
console.log(4)
```
> 1243，promise 构造函数是同步执行的，then 方法是异步执行的


#### 4. setTimeout 和 Promise 的执行顺序
``` js
setTimeout(function () {
    console.log(1)
}, 0);

new Promise(function (resolve, reject) {
    console.log(2)
    for (var i = 0; i < 10000; i++) {
        if (i === 10) {
            console.log(10)
        }
        i == 9999 && resolve();
    }
    console.log(3)
}).then(function () {
    console.log(4)
})
console.log(5);
```

#### 5. setTimeout 和 Promise 的执行顺序
``` js
setTimeout(function () {
    console.log(1)
}, 0);
new Promise(function (resolve, reject) {
    console.log(2);
    resolve();
}).then(function () {
    console.log(3)
}).then(function () {
    console.log(4)
});
process.nextTick(function () {
    console.log(5)
});
console.log(6);
```

#### 请写出下面代码的运行结果
``` js
async function async1() {
console.log('async1 start')
await async2()
console.log('async1 end')}async function async2()
{
console.log('async2')}console.log('script
start')setTimeout(function()
{
console.log('setTimeout')},
0) async1()new Promise(function(resolve)
1) {
console.log('promise1')
resolve()}).then(function()
{
console.log('promise2')})console.log('script end')
//输出
//script start
//async1 start
//async2
//promise1
//script end
//async1 end
//promise2
//setTimeout
```

#### 某跳动面试题 | 模拟实现一个 Promise.finally
``` js
Promise.prototype.finally = function (callback) {
    let P = this.constructor;
    return this.then(
        value => P.resolve(callback()).then(() => value),
        reason => P.resolve(callback()).then(() => {
            throw reason
        })
    );
};
```

#### 介绍下 Promise.all 使用、原理实现及错误处理
``` js
const p = Promise.all([p1, p2, p3]);
```
> Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例，如果不是，就会先调用下面讲到的 Promise resolve 方法，将参数转为 Promise 实例，再进一步处理。（Promise.all 方法的参数可以不是数组，但必须具有 Iterator 接
口，且返回的每个成员都是 Promise 实例。）

#### 设计并实现 Promise.race()
``` js
Promise._race = promises => new Promise((resolve, reject) => {
    promises.forEach(promise => {
        promise.then(resolve, reject)
    })
})
Promise.myrace = function (iterator) {
    return new Promise((resolve, reject) => {
        try {
            let it = iterator[Symbol.iterator]();
            while (true) {
                let res = it.next();
                console.log(res);
                if (res.done) break;
                if (res.value instanceof Promise) {
                    res.value.then(resolve, reject);
                } else {
                    resolve(res.value)
                }
            }
        } catch (error) {
            reject(error)
        }
    })
}
```

[Promise 必知必会（十道题）](https://juejin.cn/post/6844903509934997511)


[BAT前端经典面试问题：史上最最最详细的手写Promise教程](https://juejin.cn/post/6844903625769091079#heading-0)







