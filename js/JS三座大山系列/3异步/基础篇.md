## 一、定时器
> 定时器：设定一个定时器，到了设定时间，浏览器会把对应的方法执行。每一个定时器执行后都会有一个编号返回，每个定时器编号不一样。
### 1. 设定定时器
* setTimeout([function], [interval])
> function 都是在到达设定时间后才执行。且执行一次
``` js
let count = 1
let timer = setTimeout(function(){
    count++
    console.log(count)  // 2
}, 1000)
console.log(timer)  // 1
```
* setInterval([function], [interval])
> 在设定时间内执行，不主动停止的情况下一直执行。
``` js
let count = 1
let timer = setInterval(function(){
    count++
    console.log(count)  // 2
}, 1000)
console.log(timer)  // 1
/*
*   2
*   3
*   4
*   ...
*/
```
### 2. 清除定时器
> `clearTimeout/clearInterval` 两者都可以清除上面的两种定时器。
* 如何清除定时器？
> 只需要定时器的返回值编号清除即可。
```js
let count = 1
let timer = setInterval(function(){
    count++
    console.log(count)
    // count == 3 ? clearTimeout(timer) : null
    count == 3 ? clearInterval(timer) : null
}, 1000)
```

## 二、异步编程的原理
__先来看一个小例子__
``` js
let a = 0
setTimeout(() =>{
    console.log('a', ++a)
}, 0)
console.log(a)
/* 输出
*   0
*   1
*/
```
> 上面的例子中，`setTimeout` 是异步的，浏览器会将异步的代码加入到任务队列中，等到同步的代码执行完成后才执行异步的代码
### 1. 同步
> JS 是单线程的，代码至上而下执行时遇到同步的代码需要先执行完才可以进行下一步任务。比如循环等

### 2. 异步
> 所有需要等待的任务都是异步的。遇到异步代码时，不需要等待而是直接异步任务放入任务队列，等到后面的任务完成后，才会返回来执行没有完成异步的代码。比如事件绑定，所有定时器，ajax 的异步处理，部分回调函数，浏览器的渲染过程等等。
``` js
let a = 0
setTimeout(() =>{
    console.log('a', ++a)
}, 0)
console.log(a)
while(true){
}
```
> 上面的代码死循环了，即使定时器的时间到了也不会执行。因为同步的代码没有执行完一步就不会执行。

## 三、promise
### 1.基本概念
> `Promise` 只是一个管理异步编程的类，本身是同步。`Promise` 有三个状态 `pending/fulfilled/rejected`，三个状态只有两个状态出现要么成功要么失败。`new Promise()`时必须要传入回调函数 `executor`，否则报错。其中回调函数中有两个参数 `resolve, reject`，这两个参数可不写。
* `pending` ：初始化状态，开始执行异步的任务
* `fulfilled`：成功状态
* `rejected`：失败状态
__先看一个小栗子。__
``` js
new Promise(()=> {
    setTimeout(()=> {
        console.log(1)
    }, 0)
    console.log(2)
}).then()
console.log(3)
/* 输出
*   2
*   3
*   1
*/
```
> 创建一个新的 `Promise` 的实例也就是 `new` 这个过程中会把 `Promise 中` 的函数先执行(不清楚 `new` 创建实例的过程中发生了什么可以看看这篇 [面试 | 你不得不懂得 JS 原型和原型链](https://juejin.cn/post/6938590449674223624#heading-6))。函数体内有异步操作的仍会加入任务队列，等到同步执行完成后才执行异步任务，比如函数体内的 `setTimeout 函数`。所以输出的结果就是 `2，3，1`。

### 2. promise 是怎么管理异步的
> `promise` 参数的回调函数体内接收两个参数 `resolve/ reject`，这两个参数可以作为两个回调函数。
> 1. `resolve()`：是异步操作执行成功后执行，promise 的状态变成了 `fulfilled`，可以提供返回值，在 `then()` 中接收
> 2. `reject()`：异步操作执行失败后执行，promise 的状态变成了 `rejected`，可以提供返回值，在 `then()` 中接收
> `resolve()` 和 `reject()` 中 只能传递一个参数。promise 的状态发生改变后不会再变化。
> `resolve()` 和 `reject()` 是异步操作，执行这两个方法时，会先执行 `then/catch` 等，等到主任务为空时，再去调用 `resolve/reject` 把存放的方法执行。
__举一个没什么意义的小栗子__
``` js
new Promise((resolve, reject)=> {
    setTimeout(()=> {
        resolve('ok')
        // reject('fail')
    }, 0)
}).then( res => {
    console.log('status:', res)
}, res => {
    console.log('status:', res)
})
```

### 3. promise.then(onfulfilled, onrejected)
>1.  `promise.then()` 方法中有两个参数，分别对应着 promise 的两种不同的状态，`fulfilled, rejected`。对应的状态执行对应的方法。
> 2. 


### 4. promise.catch() 

## 三、async 和 await 
__先来看一个栗子__
``` js
function fn(){
    return new Promise((resolve, reject) => {
        setTimeout( () => {
            Math.random() < 0.5 ? resolve('resolve 001') : reject('reject 002')
        }, 0)
    })
}

async function get() {
    let res = await fn()
    console.log(res)
    console.log(1212)
}
get()
```
>1. `async` 和 `await` 是 ES7 中增加来对 `promise` 操作的方法，`await` 不能单独使用一定要结合 `async` 来使用，`async` 会返回一个 `promise`  对象，`async` 函数调用不会造成代码的阻塞
>2. `await` 是用来 `等待获取` 一个 `promise` 的 `resolve/reject` 的执行结果，像上面的` let res = await fn()` 可以获取 `resolve/reject` 返回的结果，不过 `await` 后面也可以不跟着一个 `promise`，但是这样写就没有意义了。
>3. 如果 await 等到的获取结果是 `reject()` 返回的，那么 await 后面的代码，就不会再执行，因为已经报错了。
>4. `await` 这个操作不是同步的，而是异步的，会导致线程阻断。`await` 可以使 `promise` 的操作更加像同步的代码。

### 思考
#### 热身1，await 是同步吗？，求输出的结果
``` js
console.log(1)
function fn(){
    return new Promise((resolve, reject) => {
        resolve('resolve 001')
    })
}

async function get() {
    console.log(2)
    let res = await fn()
    console.log(3)
}
get()
console.log(4)
/* 输出
*   1，2， 4， 3
*/
```
>`await` 是异步的，所以执行的结果中先输出了 `4` 在输出了 `3`。

## 四、思考
### 1. promise 的优缺点/为什么使用 promise？
> promise 可以解决回调地狱，promise 大大增强了嵌套函数的可读性和可维护性

### 2. promise 于 setTimeout() 区别


### 3. 实现一个 sleep 函数，比如 sleep(1000) 意味着等待 1000 毫秒。

### 4. Promise 构造函数是同步执行还是异步执行，那么 then 方法呢
> `Promise` 是同步的，执行 `new promise(callback)` 时回调函数`callback` 就会被立即执行，`then()` 方法是异步的。
``` js
const promise = new Promise((resolve, reject) => {
    console.log(1)
    resolve()
    console.log(2)
})
promise.then(() => {
    console.log(3)
})
console.log(4)
```
> 1243，promise 构造函数是同步执行的，then 方法是异步执行的


### 4. setTimeout 和 Promise 的执行顺序
``` js
setTimeout(function () {
    console.log(1)
}, 0);

new Promise(function (resolve, reject) {
    console.log(2)
    for (var i = 0; i < 10000; i++) {
        if (i === 10) {
            console.log(10)
        }
        i == 9999 && resolve();
    }
    console.log(3)
}).then(function () {
    console.log(4)
})
console.log(5);
```

### 5. setTimeout 和 Promise 的执行顺序
``` js
setTimeout(function () {
    console.log(1)
}, 0);
new Promise(function (resolve, reject) {
    console.log(2);
    resolve();
}).then(function () {
    console.log(3)
}).then(function () {
    console.log(4)
});
process.nextTick(function () {
    console.log(5)
});
console.log(6);
```

### 请写出下面代码的运行结果
``` js
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2')
}
console.log('script start ')
setTimeout(function () {
    console.log('setTimeout')
}, 0)
async1()
new Promise((resolve) => {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('promise2')
})
console.log('script end')
//输出
//script start
//async1 start
//async2
//promise1
//script end
//async1 end
//promise2
//setTimeout
```

### 某跳动面试题 | 模拟实现一个 Promise.finally
``` js
Promise.prototype.finally = function (callback) {
    let P = this.constructor;
    return this.then(
        value => P.resolve(callback()).then(() => value),
        reason => P.resolve(callback()).then(() => {
            throw reason
        })
    );
};
```

### 介绍下 Promise.all 使用、原理实现及错误处理
``` js
const p = Promise.all([p1, p2, p3]);
```
> Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例，如果不是，就会先调用下面讲到的 Promise resolve 方法，将参数转为 Promise 实例，再进一步处理。（Promise.all 方法的参数可以不是数组，但必须具有 Iterator 接
口，且返回的每个成员都是 Promise 实例。）

### 设计并实现 Promise.race()
``` js
Promise._race = promises => new Promise((resolve, reject) => {
    promises.forEach(promise => {
        promise.then(resolve, reject)
    })
})
Promise.myrace = function (iterator) {
    return new Promise((resolve, reject) => {
        try {
            let it = iterator[Symbol.iterator]();
            while (true) {
                let res = it.next();
                console.log(res);
                if (res.done) break;
                if (res.value instanceof Promise) {
                    res.value.then(resolve, reject);
                } else {
                    resolve(res.value)
                }
            }
        } catch (error) {
            reject(error)
        }
    })
}
```
## 结束


[Promise 必知必会（十道题）](https://juejin.cn/post/6844903509934997511)


[BAT前端经典面试问题：史上最最最详细的手写Promise教程](https://juejin.cn/post/6844903625769091079#heading-0)







