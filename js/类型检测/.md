## JS 中的类型
* 基本类型，number，string，null，undefined，Boolean，es6 新增的 symbol，es11
中的 bigInt 总共 7 种基本类型
* 引用类型：object，function。
## 数据类型的检测方式
> 数据类型的检测的方法中共有四种`typeof, instanceof, Object.prototype.toString.call(), constructor`

### 一、`typeof` 
> typeof 检测原理是：在计算机底层 `根据js数据类型的二进制的值进行检测的`。
* `typeof` 检测类型后的返回值是一个字符串
``` js
typeof undefined    //"undefined"
typeof 12   //"number"
typeof NaN  //"number"
typeof ''   //"string"
typeof function(){}     //"function"
```
* (缺点) `typeof` 可以检测除了 `null` 类型以外的数据型。`null` 被检测成 `object` 这是一个历史遗留的 bug。
* (缺点) `typeof` 不能检测出具体的 `object` 类型，因为对象类型的二进制开头都是 000。比如 `typeof []   //"object"` 检测数组，正则，日期等。

``` js
typeof {}   // "object"
typeof []   // "object"
typeof /^/  // "object"
```
#### 思考：typeof null 检测出来的结果为什么是 object
> `typeof` 是根据二进制值来判断数据类型的，`null` 的二进制值是 000，而 `object` 类型的二进制值都是 000 开头的，所以 `typeof` 检测 `null` 是也被检测成 `object`，这是一个历史里留下来的bug

### 二、instanceof
> `instanceof` 检测机制是：`判断右侧的类型是否出现在左侧实例的原型链上，出现了返回的结果就是true 否则是 false`。
* `instanceof` 判断返回的结果是一个 Boolean 值。
* `instanceof` 是用来检测当前的实例是否属于某个类的。可以用来解决 `typeof` 无法检测具体的对象类型的问题。
``` js
let ary = []
console.log(ary instanceof Array)   // true

let reg = /^/
console.log(reg instanceof RegExp)  // true
```
* (缺点) 只要当前类出现在实例的原型链上检测的结果就是 `true`，那么 `Object` 类型检测的结果永远都是 `true`，如果实例的原型被修改了，即使检测的结果是 `true`，也是不准确的。 
* (缺点) `instanceof` 不能检测基本数据类型。
``` js
// 出现在原型链上的类型都被判断成true
let ary = []
console.log(ary instanceof Object)   // true

function fn(){}
fn.prototype = Array.prototype  // 原型被修改了
let f = new fn()
console.log(f instanceof Array) // true
console.log(f instanceof Function) // false

// 不能检测基本数组类型
console.log(1 instanceof Number)    //false
console.log('' instanceof String)   //false
console.log(false instanceof Boolean)   //false
```
#### 思考，模拟实现 instanceof
> 思路：根据左侧实例的原型链上是否出现右侧的类型进行判断结果。即`实例.__proto__ === 类.prototype`，则是true 否则是 false。对原型和原型链不熟悉的可以看 [面试 | 你不得不懂得 JS 原型和原型链](https://juejin.cn/post/6938590449674223624)。
``` js

```