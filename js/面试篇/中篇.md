## 一、ES6 面试题
### 1. 讲讲 ES6 中 let，const 和 ES5 中 var 的区别？
1. `let` 和 `const` 不会变量提升，变量不允许在声明之前使用
2. `let` 在同一个作用域内不允许被重复声明。`const` 声明时是要被赋值，且不能再改变变量的值更不能被重新声明。
3. 全局作用域下 `let` 和 `const` 声明的变量和 `window` 之间不存在映射关系
4. `let` 和 `const` 声明变量之前使用 `typeof` 检测变量会被报错，而不是`undefined`，这是由于暂时性死区
5. `let` 和 `const` 声明的变量存在块级作用域，大括号内的基本都是块级作用域。

### 2. ES6 中的箭头函数和 ES5 中的函数有什么区别？
1. 箭头函数是匿名函数，不能作为构造函数，不能使用 new
2. 没有 `this`，箭头函数的 `this` 来源于上下文中的 `this`。关于 `this` 指向可以看看这篇 [面试 | 你不得不懂的 JS this 指向](https://juejin.cn/post/6942697803709677582)
3. 没有 `arguments`。
4. 箭头函数没有原型 `prototype` 属性。

### 3. 


## 二、DOM
### 1. 某厂面试题：了解重排 (DOM回流)和重绘吗？说一下区别
> 思路：先讲述浏览器的渲染机制->重排和重绘的概念->怎么减少重排和重绘。。。
* 浏览器渲染机制
> 浏览器会先把 `HTM`L 解析成 `DOM` 计算 `DOM` 结构；然后加载 `CSS`  解析成 `CSSOM`；最后将 `DOM 和 CSSOM` 合并生成渲染树 `Render Tree`；最后浏览器按照 `render tree` 绘制页面。

* 重排和重绘概念
  - 重排是指 `render tree` 某些 `DOM` 结构发生了变化，浏览器重新渲染 `DOM` 的这个过程就是`重排（DOM 回流）`
  - 重绘是指 页面的样式发生了改变但是 `DOM` 结构没有发生改变的话，比如颜色发生了变化，浏览器就会对需要的颜色进行重新绘制。
  - 重排会引起重绘，但是重绘不一定会引起重排。

* 如何减少重绘与回流


### 2.
1. s
2. 2
3. 3
4. 


## 三、


## 四、其他
### arguments 为什么不是数组？如何将类数组 arguments 转化成数组？
### 方式一 使用 call()，[].slice/Array.prototype.slice()
``` js
let array = [12, 23, 45, 65, 32]
function fn(array){
    var args = [].slice.call(arguments)
    return args[0]
}
fn(array)   // [12, 23, 45, 65, 32]
```
__上面的 `slice` 结合 `call` 为什么可以在改变 `this` 后可以将 `arguments` 转化成数组？我们来模拟手写实现一下 `slice`，就知道里面的原理了__
``` js
Array.prototype.mySlice = function(startIndex=0, endIndex){
    let array = this    // 通过 this 获取调用的数组
    let thisArray = []
    endIndex === undefined ? (endIndex = array.length) : null
    for(let i = startIndex; i< endIndex; i++){      // 通过 `length` 属性遍历
        thisArray.push(array[i])
    }
    return thisArray
}

// 测试一下没有问题
let arr = [1, 3, 5, 6, 7, 23]
let a 
a = arr.mySlice()   // [1, 3, 5, 6, 7, 23]
a = arr.mySlice(2, 6)   // [5, 6, 7, 23]
```
> 通过 `this` 获取调用 `mySlice` 的数组，再通过 `length` 属性遍历形成一个新的数组返回。所以改变`this` 指向 `arguments` 再通过 `arguments.length` 遍历返回一个新的数组，便实现了将类数组转化成数组了。

__**来思考一下字符串可以转化成数组吗？**__
``` js
let a = [].slice.call('stringToArray')
console.log(a)  // ["s", "t", "r", "i", "n", "g", "T", "o", "A", "r", "r", "a", "y"]
```
> 同样也是可以的，理由同上。至于字符串(值类型)为什么被 `this` 指定，可以来看看这篇文章 [面试 | call,apply,bind 的实现原理和面试题]()

### 方式二 使用ES6 的扩展运算符 `...`
``` js
function fn(array){
    var args = [...arguments]
    return args
}
fn(12, 23, 45, 65, 32)   // [12, 23, 45, 65, 32]
```

### 方式三 



