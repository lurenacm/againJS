## TCP 的报文头部字段
* 源端口号、目标端口号，通过源IP，源端口号、目标IP和目标端口。TCP 报文是没有源 IP 和目标IP的，而是通过 IP 层处理得到，TCP只需要记录两者端口号即可。
* 序列号、确认号。序列号SYN，保证数据包的传输数据。确认号用来告知对方下一个期待接收的序列号的。
* 头部长度、窗口大小


流量控制、拥堵机制等  https://www.cxyzjd.com/article/qq_43988365/106782825


## UDP 和 TCP 的区别
> UDP 和 TCP 都是传输层中的协议，这两个协议会和应用层中的传送过来的数据包结合再和网络层中的 IP 协议结合。传输到底层再发送到其他主机。UDP 和 TCP 头都包含了目标端口号和本机端口号用于指定发送的目标主机程序



__UDP__
* 面向无连接
* 速度快，适合在线视频等
* 不保证数据传输的可靠性，数据包传输过程中数据包容易丢失。只管发送，不保证能否被接收。



__TCP传输控制协议__
* 面向连接的，有三次握手的阶段，基于字节流的传输层通信协议。
* (可靠性)有重传机制，如果数据包有丢失，TCP 可以重新传
* (有状态)提供排序的序列号能准确记录数据的发送和接收状态
> 总结：TCP 和 UDP 主要的区别在于 TCP 是面向连接的，且可靠的，有状态的。



### TCP 是怎样保证重传机制和数据排序功能的(三次握手)？
[图解 TCP 三次握手](./img/TCP三次握手.jpg)
* 在开始连接之前，客户端和服务端都处于 close 状态，在服务器监听某一个端口号后为 listen 状态
* 第一次握手：建立连接。客户端向服务器发送一个请求的 `SYN` 报文。将 `SYN` 设置为1，初始序号 Sequence Number为 x (seq=x)，客户端处于`syn_send` 状态，等待服务器接收。
* 第二次握手：服务器接收 `SYN报文` 后会向客户端发送自己的 `SYN和ACK报文` 作为应答。服务器此时处于 `SYN_RCVD` 状态
* 第三次握手：客户端收到服务器的 SYN 和 ACK 报文后，会向服务器发送一个 ACK。此时客户端和服务器都处于已建立状态 (ESTABLISHED)，完成 TCP 三次握手。可以开始数据传输
> 三次握手的过程确保了双方都具备了接收和发送的能力。而且三次握手能确保数据丢失后可以重传，三次握手阶段提供了数据的排序功能
> sqe 是序列号，ACK 是确认号。
#### TCP 为什么不是二次握手，不是四次握手？
> TCP 三次握手可以检验客户端和服务端都具备接收和发送的能力。所以二次握手不能证明客户端具备接收的能力，四次握手也可以实现TCP连接，5次也可以，只是三次握手就可以解决了。


### TCP 的四次挥手
[TCP四次挥手](./img/TCP四次挥手.jpg)
* 一开始客户端和服务端都处于已建立阶段 `established`
* 第一次挥手，客户端向服务端发送 `FIN报文`，随后客户端处于 `FIN-WAIT1` 状态，等待服务端接收。
* 第二次挥手，服务端接收到 `FIN报文` 后，开始向客户端发送确认号 `ACK` 后变成 `close-wait` 关闭等待状态，客服端接收到 `ACK确认号` 后，状态变成了 `FIN-WAIT2`。
* 第三次挥手，服务端再次向客户端发送 `FIN报文和ACK`，随后服务端变成了 `last-ack` 状态
* 第四次挥手，客户端接收到服务端的 `FIN报文和ACK确认号` 后，客户端向服务器发送 `ACK确认号`，变成了 `TIME-WAIT` 状态，等到服务器接收到 `ACK` 后才处于 `closed` 关闭状态，服务器接收后也会处于 `closed` 关闭状态。


### 第四次挥手为什么需要等待 2MSL 
> MSL(Maximum Segment Lifetime，报文最大生存时间)
* 当客户端处于 TIME-WAIT 阶段时会等待 2MSL 时间，这个时间段内如果服务端没有重新发送 FIN和ACK，表示服务端接收到了客户端发送的 ACK，那么挥手结束，TCP 断开连接
* 等待 2MSL 的原因，其中 1个 MSL 是为了确保四次挥手中ACK报文能传递到接收端。另一个 MSL 可以确保在 ACK 报文没有被接收端接收到后，重传 FIN 报文的操作。 


#### 为什么 TCP 是四次挥手不是三次挥手？
> 因为服务器在接收到 FIN 报文后，不会立即向客户端发送 FIN 报文，必须要等到服务端的所有报文都发送完才会发送 FIN报文，服务端会先发送 ASK 确认，发送过来的 FIN 报文被接收。等到服务端报文发送完后才发送 FIN 报文，所以这需要四次挥手。

> 如果只需要三次握手将 FIN 和 ACK 一起发送，这会让客户端接收的时间变成，客户端无法确认服务端是否接收到 FIN 报文会多次发送。


#### HTTP 的队头阻塞 和 TCP 的队头阻塞
> 这两个不是同一种情况
*  HTTP 的队头阻塞，在同一个 TCP 长连接中，是指前一个 http 的请求没有得到响应后面的 http 就不能发送 
*  TCP 的队头阻塞，指 tcp 的数据包发生了丢失，那么后面的数据包就不会发送上去，而是重新传送。


### TCP 流量控制和拥堵控制
#### TCP 为什么需要进行拥堵控制
* 路由器会有一个数据包的处理队列，当路由器接收到得到数据包太多处理不过来时，就会将新来的数据包丢弃。那么这样的话 TCP 以为数据包没有被接接收到。就会导致 TCP 进行重传。路由器就会再次丢包，这样就会导致网络的性能下降，引起网络的瘫痪。所以 TCP 要进行控制数据包的数量来避免这种事情发生

* TCP 是一个可靠传输的原理就是超时重传机制。就是在发送一个数据包之后，会设立一个定时器，如果在定时器时间内没有接收到接收端发送过来的响应的（确认的）话。就会重新开始一个新的重传(重新开始慢开始算法)


#### 拥堵控制的方法
* 慢开始算法：由小到大逐渐增大发送的窗口，窗口就是窗口内的传输数据。一次性发送小的数据包。但是逐渐增大的数据包时指数级增加的，如果一开始窗口大小是 10，那么第一轮发送端传输完成且收到 ACK后，cwnd 变成 20，第二轮变成 40，指数增长。
* 所以需要使用拥塞避免算法。
* 拥塞避免算法：设置一个限定阈值来控制窗口数据包的一个大小，每一轮只能增加 1 。
* 还有 快重传和快恢复。


### TCP 的流量控制。
> 流量控制是指 抑制发送端到接收端的一个数据传输速率的控制。为了防止发送的数据过快，来不及接收导致丢失。
* 实现流量控制可以通过滑动窗口协议，也就是（ARQ协议）实现。

#### TCP 滑动窗口
> TCP 的滑动窗口分为发送窗口和接收窗口
* 发送窗口分为 4 大部分状态。已发送且已确认。已发送但未确认。未发送但可以发送。未发送也不可发送。这 4 大状态是数据的状态。
* 接收窗口会将接收到 发送滑动窗口的已发送数据包。

#### 流量控制的过程
 举一个例子，假设发送前各自的窗口大小都是 200 字节。假设当前 发送端给接收端发送 100字节，那么接收窗口就需要向右移动100个字节。那么接收端的可用窗口就减少了 100 个字节。

 这 100 个接收端的字节。就会放入到接收端的缓冲队列。但是接收端队列不能一次处理这么多的字节只能处理 40 个字节的话，那么剩余的 60个字节就会留在缓存队列中。

 这时接收端的处理能力就不够用了，发送端就需要少发送一点。所以接收端的接收窗口就缩小一点。通过控制窗口的大小实现 流量控制的目的。



### TCP 是怎么保证包的顺序传输的。
[TCP保证数据包传输](./img/TCP保证数据包传输.jpg)
* 发送主机每次数据时，TCP 就给每一个数据包分配一个序列号，并且在一个特定的时间等待确认号返回。
* 如果主机在规定时间内没有收到主机的确认就会重新传送数据包。


[TCP流量控制和拥堵控制](https://www.136.la/jingpin/show-62374.html)

[面试干货：TCP/IP 协议的经典面试知识点总结！](https://zhuanlan.zhihu.com/p/406117264)


relative元素以它原来的位置为基准偏移，在其移动后，原来的位置不再占据空间